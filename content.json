{"meta":{"title":"Code","subtitle":null,"description":null,"author":"liaozan","url":"https://liaozan.github.io"},"pages":[],"posts":[{"title":"jdk1.7 HashMap 浅析","slug":"HashMap1.7","date":"2018-12-24T03:43:07.034Z","updated":"2018-12-24T06:23:37.357Z","comments":true,"path":"2018/12/24/HashMap1.7/","link":"","permalink":"https://liaozan.github.io/2018/12/24/HashMap1.7/","excerpt":"","text":"1234567891011121314151617181920212223242526272829public V put(K key, V value) &#123; // 如果table为空，则进行第一次扩容 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // key为null if (key == null) return putForNullKey(value); // 根据生成的hash种子值，计算key的hash int hash = hash(key); // 寻找当前key在table中所对应的位置 int i = indexFor(hash, table.length); // 遍历table[i]对应位置的数据，即链表结构 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 如果hash相同，并key相同，则替换此处的旧值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 添加entry到table中 addEntry(hash, key, value, i); return null;&#125;123456789private void inflateTable(int toSize) &#123; // 向上取2的n次幂 int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); // 根据算出的大小创建一个entry数组 table = new Entry[capacity]; // 初始化哈希函数种子 initHashSeedAsNeeded(capacity);&#125;123456789101112131415private V putForNullKey(V value) &#123; // 循环数组第0位下标，判断是否存在值，发现为null的key，则进行替换，HashMap key可以为null，同时值也可以为null for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 存入数组第一位 addEntry(0, null, value, 0); return null;&#125;1234static int indexFor(int h, int length) &#123; // 此处采用位运算，计算出当前key在table中的位置 return h &amp; (length-1);&#125;12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 判断是否需要resize扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; // 创建entry存入table createEntry(hash, key, value, bucketIndex);&#125;1234567891011121314151617void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; // 如果旧容量已经达到系统默认最大容量 if (oldCapacity == MAXIMUM_CAPACITY) &#123; // 把threshold设置为最大值并返回 threshold = Integer.MAX_VALUE; return; &#125; // 新建一个新entry数组，大小为计算新大小（2倍table大小） Entry[] newTable = new Entry[newCapacity]; // 复制到新数组中 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; // 重新计算threshold threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125;1234567891011121314151617181920void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; // rehash，重新计算key的hash e.hash = null == e.key ? 0 : hash(e.key); &#125; // 找到当前key对应的位置，rehash之后即把链表上的元素分别插入table的具体位置 int i = indexFor(e.hash, newCapacity); // 把e的next置为null e.next = newTable[i]; // 把新table的i赋值为e newTable[i] = e; // 把next赋值给e e = next; &#125; &#125;&#125;12345678void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 这里直接找出hash key对应的table中数据 Entry&lt;K,V&gt; e = table[bucketIndex]; // 构造一个新的entry并存入table指定下标 // Entry构造方法见下方 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125;12345678910111213Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; // h -&gt; hash // k -&gt; key // v -&gt; value // n -&gt; 原本当前hash位置所存在的数据，如不存在则为null /** * 可以看出，next = n，讲传进来的entry保存为next，即插入原本链表的头部，头插法 */ value = v; next = n; key = k; hash = h;&#125;","categories":[],"tags":[]},{"title":"SpringBoot 启动分析","slug":"SpringBoot","date":"2018-10-31T09:10:07.573Z","updated":"2018-11-17T17:34:25.616Z","comments":true,"path":"2018/10/31/SpringBoot/","link":"","permalink":"https://liaozan.github.io/2018/10/31/SpringBoot/","excerpt":"","text":"SpringBoot已经成为最流行的Java开发框架,同时也是SpringCloud微服务的基石,今天就来看看SpringBoot是如何启动的吧!程序启动运行main方法直接调用静态方法启动SpringBoot，传入当前类为参数，作为primaryClass123456789101112131415@RestControllerspringboot@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,String[] args) &#123; return new SpringApplication(primarySources).run(args);&#125;public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this(null, primarySources);&#125; 1234567891011121314151617public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; // 重载的构造方法，resourceLoader 为 null this.resourceLoader = resourceLoader; // 判断传入的 primarySource 是否为空 Assert.notNull(primarySources, \"PrimarySources must not be null\"); // 保存到linkedlist this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // deduceFromClasspath(),这个方法会判断类路径下是否存在指定的类，从而决定应用程序的类型（reactive、servlet、none） this.webApplicationType = WebApplicationType.deduceFromClasspath(); // getSpringFactoriesInstances(),这个方式是实现 SpringBoot 自动装配的基础,是 Spring 自实现的SPI // 这一步是从类路径下 META-INF/spring.factories 下加载以 ApplicationContextInitializer 为key的全类名，并实例化 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 同理，加载并实例化以 ApplicationListener 为key的类 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获取程序当前运行堆栈，看是运行的哪个类的 main 方法，继而保存到上下文 this.mainApplicationClass = deduceMainApplicationClass();&#125; 上文说到getSpringFactoriesInstances()这个方法，那这个方法到底是怎么实现的呢查看方法调用，发现最后实现是在SpringApplication#getSpringFactoriesInstances(Class&lt;T&gt; type,Class&lt;?&gt;[] parameterTypes, Object... args)中贴上代码123456789101112private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,Class&lt;?&gt;[] parameterTypes, Object... args) &#123; // 获取类加载器 ClassLoader classLoader = getClassLoader(); // 最重要的代码在这！最重要的代码在这！最重要的代码在这！重要的事情说三遍！！！ Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 实例化获取到的类 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names); // 排序 AnnotationAwareOrderComparator.sort(instances); // 最后返回实例化好的对象 return instances;&#125; 让我们来看看SpringFactoriesLoader.loadFactoryNames(type, classLoader)到底干了什么呢？123456789101112131415161718192021222324252627282930313233343536373839404142434445public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; // 先试着从缓存中获取 MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; // 简化部分逻辑 // classLoader.getResources() 是从类路径下加载资源 // 翻看类成员定义，可以发现 FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); result = new LinkedMultiValueMap&lt;&gt;(); // 迭代获取的资源 while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); // 用当前url实例化一个UrlResource，表示一个Spring资源 UrlResource resource = new UrlResource(url); // 加载资源到内存中 Properties properties = PropertiesLoaderUtils.loadProperties(resource); // 遍历当前资源的键值对 for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 获取key String factoryClassName = ((String) entry.getKey()).trim(); // StringUtils.commaDelimitedListToStringArray(str) 把传入的字符串按逗号分隔为数组 // 遍历获取key对应的value for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; // 加到map中 result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; // 最后加入缓存 cache.put(classLoader, result); // 返回结果 return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [\" +FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125;&#125; 注释已经写的很详细了，这段代码的作用就是从类路径META-INF下加载spring.factories文件，并将其读入内存、解析，最后存入缓存中那这么做有什么用呢？我们看一下spring.factories里到底有什么呢？(代码截取自spring-boot-autoconfigure-2.1.0.RELEASE.jar!/META-INF/spring.factories)1234567891011121314151617181920212223242526# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\省略部分代码...org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 可以看到刚才代码中出现了刚才获取的getSpringFactoriesInstances(ApplicationContextInitializer.class)它所对应的value:12org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializerorg.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener 不难发现，Spring通过在META-INF/spring.factories里提前定义好需要在应用程序启动期间所需要的组件，如ApplicationContextInitializer、ApplicationListener、AutoConfigurationImportListener以及自动配置的关键EnableAutoConfiguration 以常用的json解析jackson为例,这里贴出部分代码org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration123456789101112131415161718192021222324252627282930313233343536// Configuration表明这是一个配置类@Configuration// CondictionOnClass注解表明当类路径下存在指定类时,才会激活此自动配置// 类似注解还有 ConditionalOnBean、ConditionalOnMissingClass、ConditionalOnMissingBean等等@ConditionalOnClass(ObjectMapper.class)public class JacksonAutoConfiguration &#123; private static final Map&lt;?, Boolean&gt; FEATURE_DEFAULTS; static &#123; // 配置ObjectMapper序列化不将Date序列化为时间戳 Map&lt;Object, Boolean&gt; featureDefaults = new HashMap&lt;&gt;(); featureDefaults.put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); FEATURE_DEFAULTS = Collections.unmodifiableMap(featureDefaults); &#125; @Bean public JsonComponentModule jsonComponentModule() &#123; return new JsonComponentModule(); &#125; @Configuration // 类路径下存在 Jackson2ObjectMapperBuilder 这个类时,进行Jackson的自动配置 @ConditionalOnClass(Jackson2ObjectMapperBuilder.class) static class JacksonObjectMapperConfiguration &#123; @Bean @Primary // 只有当容器中不存在用户自定义的ObjectMapper,才会自动往容器里注入一个ObjectMapper实例对象 @ConditionalOnMissingBean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123; return builder.createXmlMapper(false).build(); &#125; &#125;&#125; 关于SpringBoot自动配置,有时间再单独写一篇文章说明 SpringApplication#run() 方法逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ConfigurableApplicationContext run(String... args) &#123; // 启动时间记录 StopWatch stopWatch = new StopWatch(); stopWatch.start(); // 申明 ICO 容器对象,在 try-catch 中进行初始化,以便在出现异常时可以将 IOC 作为参数传入 ConfigurableApplicationContext context = null; // 创建一个 list,用于存放所有 SpringBootExceptionReporter Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 设置系统属性java.awt.headless configureHeadlessProperty(); // 获取所有启动时监听器 SpringApplicationRunListeners listeners = getRunListeners(args); // 调用所有监听器的starting方法,SpringBoot正在启动 listeners.starting(); try &#123; // 根据传入的参数创建 ApplicationArguments 实例 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 准备应用上下文 environment 对象 ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments); // 设置是否忽略bean信息 configureIgnoreBeanInfo(environment); // 打印banner Banner printedBanner = printBanner(environment); // 创建IOC容器 context = createApplicationContext(); // 获取异常报告，以便在出异常时报告异常信息 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 准备上下文 prepareContext(context, environment, listeners, applicationArguments,printedBanner); // 刷新上下文 refreshContext(context); // 刷新完之后 afterRefresh(context, applicationArguments); // 启动完成 stopWatch.stop(); // 打印启动信息 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; // 回调监听器的 started 方法 listeners.started(context); // 调用实现了 ApplicationRunner、CommandLineRunner 的对象的 run 方法 callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; // 启动出现异常,打印异常信息 handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 回调监听器的 listening 方法,SpringBoot 启动完成! listeners.running(context); &#125; catch (Throwable ex) &#123; // 同上 handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; 下面我们逐字逐句的来拆解 SpringBoot 启动的流程SpringApplicationRunListeners listeners = getRunListeners(args);12345// 此处再次用到 loadSpringFactories 加载所有实现了 SpringApplicationRunListener 的实现类private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125; SpringApplicationRunListener 和 ApplicationEvent 的区别: 相同: 两者都可以在应用启动时监听到不同周期的事件,可以在启动时做扩展 不同: SpringApplicationRunListener是SpringBoot才有的,实现它需要实现所有方法,包含所有周期 ApplicationEvent 是继承自 JDK 的 EventObject,默认只处理某一个生命周期的事件 ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);12345678910111213141516private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,ApplicationArguments applicationArguments) &#123; // Create and configure the environment ConfigurableEnvironment environment = getOrCreateEnvironment(); // 添加 ConversionService 转换器,保存启动参数 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 回调监听器 environmentPrepared 方法 listeners.environmentPrepared(environment); // 将 environment 绑定到当前上下文 bindToSpringApplication(environment); // isCustomEnvironment 用户是否自定义了 environment if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment;&#125; configureEnvironment方法中configurePropertySources,合并了命令行启动参数到当前 enviroment其中configureEnvironment()方法中configureProfiles()中有一行代码environment.getActiveProfiles(),跟下去可以发现最后调用了org.springframework.core.env.AbstractEnvironment#doGetActiveProfiles(),作用就是从配置文件中(包括运行参数中)获取当前运行环境,比如 dev、prod12345678910111213protected Set&lt;String&gt; doGetActiveProfiles() &#123; // 默认为空 synchronized (this.activeProfiles) &#123; if (this.activeProfiles.isEmpty()) &#123; // 从配置文件中获取 spring.profiles.active 的值 String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME); if (StringUtils.hasText(profiles)) &#123; setActiveProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles))); &#125; &#125; return this.activeProfiles; &#125;&#125; 此处是从 environment 中获取 spring.profile.active 的值,如果没有设置,最后会设置为 default,代码在org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#initializeProfiles1234567891011121314151617private void initializeProfiles() &#123; // The default profile for these purposes is represented as null. We add it // first so that it is processed first and has lowest priority. this.profiles.add(null); Set&lt;Profile&gt; activatedViaProperty = getProfilesActivatedViaProperty(); this.profiles.addAll(getOtherActiveProfiles(activatedViaProperty)); addActiveProfiles(activatedViaProperty); if (this.profiles.size() == 1) &#123; // only has null profile // 如果没有设置 profile ,则使用默认 profile // org.springframework.core.env.AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\" // org.springframework.core.env.AbstractEnvironment#RESERVED_DEFAULT_PROFILE_NAME = \"default\" for (String defaultProfileName : this.environment.getDefaultProfiles()) &#123; Profile defaultProfile = new Profile(defaultProfileName, true); this.profiles.add(defaultProfile); &#125; &#125;&#125; Banner printedBanner = printBanner(environment);123456789101112131415private Banner printBanner(ConfigurableEnvironment environment) &#123; // 如果当前设置了不打印 banner if (this.bannerMode == Banner.Mode.OFF) &#123; return null; &#125; // 创建资源加载器 ResourceLoader resourceLoader = (this.resourceLoader != null)? this.resourceLoader : new DefaultResourceLoader(getClassLoader()); // 创建 printer SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner); // 打印 banner if (this.bannerMode == Mode.LOG) &#123; return bannerPrinter.print(environment, this.mainApplicationClass, logger); &#125; return bannerPrinter.print(environment, this.mainApplicationClass, System.out);&#125; 打印 banner1234567891011121314151617181920212223242526public Banner print(Environment environment, Class&lt;?&gt; sourceClass, Log logger) &#123; Banner banner = getBanner(environment); try &#123; logger.info(createStringFromBanner(banner, environment, sourceClass)); &#125; catch (UnsupportedEncodingException ex) &#123; logger.warn(\"Failed to create String for banner\", ex); &#125; return new PrintedBanner(banner, sourceClass);&#125;private Banner getBanner(Environment environment) &#123; Banners banners = new Banners(); // 获取图片 banner,不为空则加入 banners.addIfNotNull(getImageBanner(environment)); // 获取文字 banner,不为空则加入 banners.addIfNotNull(getTextBanner(environment)); if (banners.hasAtLeastOneBanner()) &#123; return banners; &#125; if (this.fallbackBanner != null) &#123; return this.fallbackBanner; &#125; // 如果都不存在,使用默认banner return DEFAULT_BANNER;&#125; context = createApplicationContext() 打印完banner,接下来就是创建IOC容器的时候了,代码比较简单,就不贴了,就是判断当前的应用环境,最后调用BeanUtils.instantiateClass(contextClass)实例化IOC容器 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] { ConfigurableApplicationContext.class }, context) 获取所有异常上报类,用于在启动发生异常时上报异常信息,原理同样是加载类路径下的spring.facotories文件 prepareContext(context, environment, listeners, applicationArguments,printedBanner)1234567891011121314151617181920212223242526272829303132333435private void prepareContext(ConfigurableApplicationContext context,ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 给当前上下文设置 environment context.setEnvironment(environment); // 设置 beanNameGenerator、resourceLoader、ConversionService postProcessApplicationContext(context); // 获取所有 ApplicationContextInitializer,并调用其 initialize 方法 applyInitializers(context); // 回调监听器的 contextPrepared 方法 listeners.contextPrepared(context); if (this.logStartupInfo) &#123; // 打印启动进程信息 // Starting DemoApplication on liaozandeMacBook-Pro.local with PID 64442 (/Users/liaozan/IdeaProjects/demo/target/classes started by liaozan in /Users/liaozan/IdeaProjects/demo) logStartupInfo(context.getParent() == null); // 打印 profile 信息 logStartupProfileInfo(context); &#125; // Add boot specific singleton beans // 注册 SpringBoot 特有的单实例 ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(\"springBootBanner\", printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; // 设置是否允许重写 beanDefinition ((DefaultListableBeanFactory) beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, \"Sources must not be empty\"); // 创建 BeanDefinitionLoader,用于加载 beanDefinition,此处是加载应用启动类,即标注了 @SpringBootApplication 的主类 load(context, sources.toArray(new Object[0])); // 回调监听器 contextLoaded 方法 listeners.contextLoaded(context);&#125; 关于 allowBeanDefinitionOverriding 这一段代码还是在初始化 SpringBoot ,设置注册了一些 SpringBoot 独有的 bean 实例,同时加载了主类 refreshContext(context)123456789101112131415private void refreshContext(ConfigurableApplicationContext context) &#123; // 刷新上下文,此时正式进行 Spring 的启动逻辑 refresh(context); // 注册停止钩子函数,便于在应用程序shutdown的时候销毁所有 bean 实例 // 以 DisposableBean 为例,在应用程序停止时，会调用 org.springframework.context.support.AbstractApplicationContext#doClose 方法,一路往下跟,进入到 destroyBeans()方法 // 再到 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroyBean,最后发现调用了 bean.destroy() 方法,完成 bean 的销毁 if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125;&#125; refresh(context) refresh方法最后调用的是 org.springframework.context.support.AbstractApplicationContext#refresh 方法,进入Spring的启动流程,本文暂且只讨论SpringBoot的启动,有兴趣的小伙伴可以看这,死磕 Spring 系列 afterRefresh(context, applicationArguments)这个方法SpringBoot并没有实现,如果有需要可以继承 org.springframework.boot.SpringApplication,并重写afterRefresh(context, applicationArguments) stopWatch.stop()应用启动完成 new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch)打印启动耗时 listeners.started(context)SpringBoot 启动过程倒数第二个监听周期 callRunners(context, applicationArguments)调用实现了 ApplicationRunner、CommandLineRunner 的对象的 run 方法 listeners.running(context)最后一个事件监听周期,到此 SpringBoot 应用程序启动完成 到此,SpringBoot启动流程就写完了,这也是本人第一次写文章,如果有写的不对的地方,欢迎指出！","categories":[],"tags":[]}]}